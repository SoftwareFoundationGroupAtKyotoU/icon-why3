use export int.Int
use export int.Abs
use export int.EuclideanDivision
use export list.List
use export option.Option
use export map.Map
use export map.Const

exception Insufficient_mutez
exception Terminate

type nat = int

type mutez = int

type bytes = string

type big_map 'a 'b = map 'a 'b

type address = int

type key_hash = int

type timestamp = int

type contract 'a = int

type or 'a 'b = Left 'a | Right 'b

type lambda 'a 'b = 'a -> 'b

type step =
  { source: address;
    sender: address;
    self: address;
    amount: mutez;
    level: nat;
    now: timestamp
  }

function mk_step
    (source : address)
    (sender : address)
    (self : address)
    (amount : mutez)
    (level : nat)
    (now : timestamp) : step =
  { source= source;
    sender= sender;
    self= self;
    amount= amount;
    level= level;
    now= now }

predicate step_wf (st : step) =
  st.amount >= 0
